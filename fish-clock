#!/usr/bin/env perl

# --- if -f is given, we stay in the foreground.
#
# otherwise we fork, so that 'fish-clock' from the command line goes straight to the background.
#
# in that case, we do as much prep work as possible before forking.  
#
# then, the clock thread is spawned, which has its own ticker to keep the
# time updated, and syncs with the system clock every minute by default.

use 5.18.0;

package main;

my $top_dir;
my $script_name;
my $libmain_dir;
my $libfish_dir;

BEGIN {
    my $BIN_NAME = 'fish-clock';

    use File::Basename;
    use Cwd 'realpath';

    $script_name = basename $0;
    $top_dir = dirname realpath $0;

    my $libmain_dir = $top_dir . '/libmain';

    unshift @INC, $libmain_dir;
    unshift @INC, $top_dir . '/libextra/fish-lib-perl';
    unshift @INC, $libmain_dir . '/fish_clock_xs/lib';
    unshift @INC, $libmain_dir . '/fish_clock_xs/blib/lib/auto/fish_clock_xs';
    unshift @INC, $libmain_dir . '/fish_clock_xs/blib/arch/auto/fish_clock_xs';

    $0 = $BIN_NAME;
}

use threads;
use threads::shared;

# --- force END block on Ctl-c / kill.
$SIG{INT} = $SIG{TERM} = sub { exit };

use Glib;

use Time::HiRes qw, time sleep ,;
use List::Util 'max';
use POSIX 'setuid';

use constant BENCHMARK => 0;

# --- compile away DEBUG blocks unless we're not invoked with
# -Mconstant=DEBUG,1
#
# just like 'use constant DEBUG => 0' but conditional.

use if ! defined &DEBUG, 'constant',  DEBUG => 0;

use if DEBUG, 'Fish::Utility_m' => 'd';

sub forkk;

sub bench_start(_)  { if (BENCHMARK) { return Fish::Clock::Utility::bench_start(@_) } }
sub bench_end(_)    { if (BENCHMARK) { return Fish::Clock::Utility::bench_end(@_) } }
sub bench_end_pr(_) { if (BENCHMARK) { return Fish::Clock::Utility::bench_end_pr(@_) } }
sub bench_pr(_)     { if (BENCHMARK) { return Fish::Clock::Utility::bench_pr(@_) } }

use Fish::Opt 'opt';
use Fish::Utility;
Fish::Utility->verbose_cmds(0);
use Fish::Utility_l 'list';
use Fish::Utility_m 'is_multiple';
use Fish::Class 'o';
use Fish::Socket::Server::unix;

use Fish::Clock::Conf 'cr';

my $config = o(
    # --- modules to require later (at runtime).
    #
    # Fish::Clock::Clock is here because we have to be sure that there is an
    # X server somewhere (or else libaosd splatters).

    late_use => [
        'Fish::Clock::Clock',
    ],

    required_conf => [
        'socket-path',
        'active-ms',
    ],

    main_conf => '/usr/share/fish-clock/config',

    conf_files => undef,

    x_sleep => 1,

);

$config->conf_files([
    $config->main_conf,
    "__HOME__/.fish-clock-config",
]);

my $opt = opt {
    h   => 'f',
    v   => 'f',
    f   => 'f',
    l   => 'f',
} or error help();

info(help()),
    exit if $opt->h;

Fish::Utility->info_level($opt->v ? 1 : 0);

# --- die if there are other instances running.
check_unique();

# --- get username based on main config, call setuid(), and update __HOME__
# placeholders in config.

update_uid_and_home();

Fish::Clock::Conf->init({
    required    => $config->required_conf,
    conf_files  => $config->conf_files,
    dump        => $opt->l,
});

exit if $opt->l;

my $g = o(
    state => 0,
    clock => undef,
    cur_timeout => undef,
    socket_path => cr 'socket-path',
    socket => undef,
    am_child => 0,
    xres    => cr 'xres',
    gloop   => Glib::MainLoop->new,
);

$g->socket(make_socket());

add_socket_listener() or
    error "Couldn't add socket listener.";

go(),
    exit if $opt->f;

info "Forking.";

# --- fork and kill parent.
exit 0 if forkk;

$g->am_child(1);

go(); 
exit;

END {
    cleanup_socket();
}


# - - -

sub go { 
    
    my $hour :shared = undef;
    my $min :shared = undef;
    my $sec :shared = undef;

    async { clock_thread(\$hour, \$min, \$sec) }->detach;

    while (not x_is_running()) {
        my $xs = $config->x_sleep;
        info "X doesn't seem to be running, sleeping", Y $xs;
        sleep $xs;
    }

    use_late_modules(); # Fish::Clock::Clock

    $g->clock( Fish::Clock::Clock->new(
            hour => \$hour,
            mins => \$min,
            sec => \$sec,

            xres => $g->xres,
        )
    );

    info "Ready.";

    $g->gloop->run;
} 

sub timeout { shift if $_[0] eq __PACKAGE__;
    my ($ms, $sub) = @_;
    Glib::Timeout->add($ms, $sub) or iwar "Couldn't add glib timeout";
}

sub remove_timeout {
    my ($id) = @_;
    Glib::Source->remove($id) or iwar "Couldn't remove glib timeout", BR $id;
}

sub show {
    my ($opts) = @_;
    $opts //= {};
    my $fill = $opts->{fill};
    return if $g->state;

bench_start 'show';

    $g->clock->fill($fill);

    my $t1 = time;
    $g->clock->show or
        iwar, next;
    $g->state(1);

    my $default_time = cr 'active-ms';
    my $sl = max(0, $default_time - (time - $t1));
    info '$sl (timeout) was', $sl if DEBUG;

    remove_timeout $g->cur_timeout if defined $g->cur_timeout;
    $g->cur_timeout( timeout $sl, sub {
        return unless $g->state;
        info 'hiding in timeout' if DEBUG;
        hide();
        $g->cur_timeout(undef);

        0
    });
bench_end 'show';

bench_pr for qw, renderer-config renderer-render show 
    show-clock.1 show-clock.2 show-clock.3.1 show-clock.3.2 show-clock.4
,;
}

sub hide {
    return unless $g->state;
    info 'hiding' if DEBUG;
    $g->clock->hide or warn, next;
    $g->state(0);
}

sub help {
    return "Usage: $0 [-h] [-v for verbose] [-f to stay in foreground] [-l to dump config and quit].";
}

# Updates the global, shared variables $hour, $min, $sec.
sub clock_thread {
    my ($hourr, $minr, $secr) = @_;

    my $i = -1;
    while (1) {
        my $t1 = time;
        if (is_multiple ++$i, 60) {
            ($$hourr, $$minr, $$secr) = update_time_sys();
            $i = 0;
        }
        else {
            if (++$$secr == 60) {
                $$secr = 0;
                if (++$$minr == 60) {
                    $$minr = 0;
                    $$hourr++;
                }
            }
        }
        info 'hr', $$hourr, 'm', $$minr, 's', $$secr if DEBUG;

        # --- sleep the remainder of 1 second.
        my $sleep = 1 - (time - $t1);
        sleep $sleep unless $sleep <= 0;
    }
}

sub update_time_sys {
    info 'Syncing time with system.';

    my $time = sys 'date +%I:%M:%S';
    my ($hr, $m, $s) = split /:/, $time;

    (int $hr, int $m, int $s)
}

sub make_socket {
    my $socket = Fish::Socket::Server::unix->new(
        path => $g->socket_path,
        unlink => 0,
    );
    sys sprintf qq, chmod a+w "%s" ,, $g->socket_path;

    $socket
}

sub update_uid_and_home {
    my $user = Fish::Clock::Conf->pre_init($config->main_conf);
    my $name = change_user($user);
    my $home = home($name);

    s, __HOME__ ,$home,gx for @{ $config->conf_files };

    if (DEBUG) {
        info 'change to user:', $user;
        info 'name', $name;
        info 'home', $home;
        info 'conf_files:', d $config->conf_files;
    }

}

sub add_socket_listener {
    my $socket = $g->socket;
    my $fileno = fileno($socket->listener);
    return war "Invalid fileno", R $fileno if not $fileno or $fileno == -1;

    Glib::IO->add_watch($fileno, 'in', sub {
        # Blocking, but we know there's something waiting.
        my $s = $socket->listen;

        if (not defined $s) {
            return 1;
        }

        chomp $s;
        $socket->say('');

        info 'Got message on socket:', $s if DEBUG;

        if ($s eq 'toggle') {
            $g->state ? hide() : show();
        }
        elsif ($s eq 'toggle-fill') {
            $g->state ? hide() : show({fill => 1});
        }
        elsif ($s eq 'show') {
            show();
        }
        elsif ($s eq 'show-fill') {
            show({fill => 1});
        }
        elsif ($s eq 'hide') {
            hide();
        }
        1;
    })
}


sub change_user {
    my ($u) = @_;
    my ($name, $id);
    if ($u !~ /\D/) {
        $name = getpwuid($u) // 
            error "Can't find uid", R $u;
        $id = $u;
    }
    else {
        $id = getpwnam($u) // 
            error "Can't find user", R $u;
        $name = $u;
    }
    setuid($id) // 
        error sprintf "Can't change uid to %s: %s", R $id, $!;
    infof "Changed user -> %s [%s]", CY $id, G $name;
    return $name;
}

# --- get the home dir for a user.
#
# assumes already setuid'd

sub home {
    my ($user) = @_;
    while ( my ($name,$passwd,$uid,$gid,$quota,$comment,$gcos,$dir,$shell,$expire) = getpwent ) {
        if ($name eq $user) {
            return war "Dir", BR $dir, "doesn't seem to be a valid home dir"
                unless -d $dir;
            return $dir;
        }
    }
    war "Can't find home dir for user", BR $user;
}

sub check_unique {
    # don't need pid actually, pgrp is good enough.
    # pgrp is better than pid because you can catch 
    #  /bin/sh /etc/init.d/fish-clock
    #  fish-clock
    # while looks like 2 processes.
    my @ps = sysll qq| ps -opid=,pgrp= -C $script_name |, { die => 0, killerr => 1, quiet => 1 };
    my @pids;
    my $my_pgrp = getpgrp;
    for (@ps) {
        $_ = strip;
        my ($pid, $pgrp) = split;
        push @pids, $pid if $pgrp != $my_pgrp;
    }
    my @e = map { sprintf "Another instance is already running (pid %s) ", CY $_ } @pids;
    error @e if @e;
}

# --- dies.
sub use_late_modules {
    eval "use $_; 1" or error "Can't use", R $_, "$@" for list $config->late_use;
}

sub x_is_running {
    $ENV{DISPLAY} = ":0"; # XX
    return sys_ok qq, xset q ,, {quiet => 1, killerr => 1},;
}

# --- dies if system call fails.
sub forkk {
    my $pid = fork // error "Couldn't fork", R $!;

    $pid
}

# --- called from END -- $opt and $g not guaranteed to exist.
sub cleanup_socket {
    my $sock;
    if (($opt and $opt->f) or ($g and $g->am_child)) {
        if ($g and $sock = $g->socket) {
            info 'Destroying socket';
            $sock->DESTROY; 
        }
    }
}
